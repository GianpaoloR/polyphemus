--------- POLYPHEMUS.H --------------
///<summary> Vector to be filled by Haar analysis (nose).</summary>
std::vector<cv::Rect> noses;
///<summary> Vector to be filled by Haar analysis (left eye).</summary>
std::vector<cv::Rect> leftEyes;
///<summary> Vector to be filled by Haar analysis (right eye).</summary>
std::vector<cv::Rect> rightEyes;
///<summary> Vector to be filled by Haar analysis (eye couple).</summary>
std::vector<cv::Rect> eyePairs;
///<summary> Vector to be filled by Haar analysis (single eye).</summary>
std::vector<cv::Rect> singleEyes;
///<summary> Vector to be filled by Haar analysis (mouth).</summary>
std::vector<cv::Rect> mouths;

    ///<summary> Find nose through Haar classifier. Called by trackGaze(). Returns void.</summary>
    void detectNoseWithHaar();
    ///<summary> Find mouth through Haar classifier. Called by trackGaze(). Returns void.</summary>
    void detectMouthWithHaar();
    ///<summary>Applies Haar analysis (eye pairs, left eye, right eye detection) and sets rois accordingly. Called by trackGaze(). Returns void.</summary>
    void detectEyesWithHaar();

    void templateMatching(); //TEMPORARY SIMONE'S METHOD
    void antropometricFilter(); //TEMPORARY SIMONE'S METHOD


---------_POLYPHEMUS_----------------


void polyphemus::antropometricFilter()
{
    if (rH->hasMouth() && rH->hasNose())
    {
        cv::Rect n = rH->getNose();
        cv::Rect m = rH->getMouth();

        if ((n.y + n.height/2) > (m.y + m.height/2))
        {
            rH->clearMouth();
            rH->clearNose();
        }
    }
}

void polyphemus::detectMouthWithHaar()
{
    mouths.clear();
    rH->clearMouth();
    haar->detectMouths(rH->getFaceROI(), rH->getFace());
    mouths = haar->getMouths();
    if (mouths.size()) {
        rH->setMouthROI(mouths);
    }
}

void polyphemus::detectNoseWithHaar()
{
    noses.clear();
    rH->clearNose();
    haar->detectNoses(rH->getFaceROI(), rH->getFace());
    noses = haar->getNoses();
    if (noses.size()) {
        rH->setNoseROI(noses);
    }
}

void polyphemus::detectEyesWithHaar()
{
    cv::Mat m;
    rH->clearHaarEyes();

    eyePairs.clear();
    haar->detectEyePairs(rH->getFaceROI(), rH->getFace());
    eyePairs = haar->getEyePairs();
    if (eyePairs.size()) {
        m = rH->getGrayFrame();
        //fH->setEyePairROI(eyePairs);
        rH->setEyePairROI(eyePairs);
    }

    //Detect single eyes
    /*singleEyes.clear();
    haar->detectSingleEyes(fH->getFaceROI(), fH->getFace());
    singleEyes = haar->getSingleEyes();
    if (singleEyes.size()) {
        fH->setEyesHaarROI(singleEyes);
    }*/

    //Detect left eyes
    leftEyes.clear();
    haar->detectLeftEyes(rH->getFaceROI(), rH->getFace());
    leftEyes = haar->getLeftEyes();
    if (leftEyes.size()) {
        rH->setLeftEyeROI(leftEyes);
    }

    //Detect right eyes
    rightEyes.clear();
    haar->detectRightEyes(rH->getFaceROI(), rH->getFace());
    rightEyes = haar->getRightEyes();
    if (rightEyes.size()) {
        rH->setRightEyeROI(rightEyes);
    }
}



//TEMPORARY SIMONE'S METHOD
void polyphemus::templateMatching()
{
    if ( rH->hasNose())
    {
        rH->setOldNose();
    }

    if( !rH->hasNose() && rH->itHasDistanceNoseMouth)
    {
        noses.clear();
        noses[0] = MatchingMethod(rH->getFaceROI(), rH->getOldHaarNoseROI());
        rH->setNoseROI(noses);

        #ifdef KETROD_DEBUG
        namedWindow("TEST$", WINDOW_AUTOSIZE);
        imshow("TEST$", rH->getFaceROI());
        #endif //KETROD_DEBUG
    }
    //detectNoseWithMatchingMethod();


    //-------------
    if ( rH->hasMouth())
    {
        rH->setOldMouth();
    }

    if (!rH->hasMouth() && rH->itHasDistanceNoseMouth)
    {
        mouths.clear();
        mouths[0] = MatchingMethod(rH->getFaceROI(), rH->getOldHaarMouthROI());
        rH->setMouthROI(mouths);

        #ifdef KETROD_DEBUG
        namedWindow("TEST$", WINDOW_AUTOSIZE);
        imshow("TEST$", rH->getFaceROI());
        #endif //KETROD_DEBUG
    }
}



-----------_HAAR ANALYZER_----------------
//detectLeftEyes: looks for left eyes and saves data into haarAnalyzer::leftEyes vector.
void haarAnalyzer::detectLeftEyes(cv::Mat& img, cv::Rect& face) {
    cv::Mat subImg = img(cv::Rect(0, face.height * 0.1, face.width * 0.66, face.height * 0.5));
    //leftEye_cascade.detectMultiScale(subImg, leftEyes, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(30, 30));
    leftEye_cascade.detectMultiScale(subImg, leftEyes, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(0.1 * face.width, 0.05 * face.height));

    for (uint i = 0; i < leftEyes.size(); i++) {
        leftEyes[i].y += face.height*0.1;
    }

    #ifdef WITH_GUI
    if (gui != NULL) {
        gui->showFaceElements(leftEyes, face);
    }
    #endif //WITH_GUI

    return;
}

//detectRightEyes: looks for right eyes and saves data into haarAnalyzer::rightEyes vector.
void haarAnalyzer::detectRightEyes(cv::Mat& img, cv::Rect& face) {
    int left = (int)face.width * 0.33;
    cv::Mat subImg = img(cv::Rect(left, face.height * 0.1, face.width - left, face.height * 0.5));
    //rightEye_cascade.detectMultiScale(subImg, rightEyes, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(30, 30));
    rightEye_cascade.detectMultiScale(subImg, rightEyes, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(0.1 * face.width, 0.05 * face.height));

    for (uint i = 0; i < rightEyes.size(); i++) {
        rightEyes[i].y += face.height * 0.1;
        rightEyes[i].x += left;
    }

    #ifdef WITH_GUI
    if (gui != NULL) {
        gui->showFaceElements(rightEyes, face);
    }
    #endif //WITH_GUI

    return;
}


//detectNoses: looks for noses and saves data into haarAnalyzer::noses vector.
void haarAnalyzer::detectNoses(cv::Mat& img, cv::Rect& face)
{
    int cutImageY = (int)(img.rows/4);
    int cutImageX = (int)(img.cols/5);
    cv::Mat subImg = img(cv::Rect(cutImageX, cutImageY, img.cols - cutImageX, img.rows - cutImageY));
    //nose_cascade.detectMultiScale( subImg, noses, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(30, 30) );
    nose_cascade.detectMultiScale( subImg, noses, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(0.1 * face.width, 0.1 * face.height) );

    for( uint i = 0; i < noses.size(); i++ )  //per ogni faccia
    {
        noses[i].y += cutImageY;
        noses[i].x += cutImageX;
    }

#ifdef WITH_GUI
    if(gui!=NULL)
    {
        gui->showFaceElements(noses, face);
    }
#endif //WITH_GUI

    return;
}



//getNoses: getter method
std::vector<cv::Rect> haarAnalyzer::getNoses()
{
    return noses;
}

//getLeftEyes: getter method
std::vector<cv::Rect> haarAnalyzer::getLeftEyes() {
    return leftEyes;
}

//getRightEyes: getter method
std::vector<cv::Rect> haarAnalyzer::getRightEyes() {
    return rightEyes;
}

//getEyePairs: getter method
std::vector<cv::Rect> haarAnalyzer::getEyePairs() {
    return eyePairs;
}

//getSingleEyes: getter method
std::vector<cv::Rect> haarAnalyzer::getSingleEyes() {
    return singleEyes;
}


//detectEyePairs: looks for eyes region and saves data into haarAnalyzer::eyePairs vector.
void haarAnalyzer::detectEyePairs(cv::Mat& img, cv::Rect& face) {
    cv::Mat subImg = img(cv::Rect(0, 0, face.width, face.height * 0.5));

    eyePair_cascade.detectMultiScale(subImg, eyePairs, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(0.1 * face.width, 0.05 * face.height));

    #ifdef WITH_GUI
    if (gui != NULL) {
        gui->showFaceElements(eyePairs, face);
    }
    #endif //WITH_GUI

    return;
}
//detectSingleEyes: looks for eyes and saves data into haarAnalyzer::singleEyes vector.
void haarAnalyzer::detectSingleEyes(cv::Mat& img, cv::Rect& face) {
    int eyeWidth = face.width * (kEyePercentWidth/100.0);
    int eyeHeight = face.width * (kEyePercentHeight/100.0);
    int eyeTop = face.height * (kEyePercentTop/100.0);

    std::vector<cv::Rect> eyeZone;
    //Rect constructor: Rect(topleft.x, topleft.y, width, height)
    eyeZone.push_back(cv::Rect(face.width*(kEyePercentSide/100.0),
                               eyeTop,
                               eyeWidth,   //width
                               eyeHeight)); //height


    eyeZone.push_back(cv::Rect(face.width - eyeWidth - face.width*(kEyePercentSide/100.0),
                               eyeTop,   //suppose horizontally aligned head!!!
                               eyeWidth,
                               eyeHeight));

    //cv::Mat subImg = img(cv::Rect(face.width*(kEyePercentSide/100.0), eyeTop, face.width - 2*face.width*(kEyePercentSide/100.0), eyeHeight));
    cv::Mat subImg = img(cv::Rect(0, 0, face.width, face.height/2));
    //singleEye_cascade.detectMultiScale( subImg, singleEyes, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, cv::Size(30, 30) );
    singleEye_cascade.detectMultiScale( subImg, singleEyes, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, cv::Size(0.1 * face.width, 0.05 * face.height) );

    //UO
    for( uint i = 0; i < singleEyes.size(); i++ )  //per ogni faccia
    {
        //singleEyes[i].x += face.width*(kEyePercentSide/100.0);
        singleEyes[i].x += 0;
        singleEyes[i].y += 0;
    }

    #ifdef WITH_GUI
    if(gui!=NULL)
    {
        gui->showFaceElements(singleEyes, face);
    }
    #endif //WITH_GUI

    return;
}

std::vector<cv::Rect> haarAnalyzer::getMouths()
{
    return mouths;
}

//detectMouths: looks for faces and saves data into haarAnalyzer::faces vector.
void haarAnalyzer::detectMouths(cv::Mat& img, cv::Rect& face)
{
    int cutImageY = (int)(img.rows/2);
    int cutImageX = (int)(img.cols/5);
    cv::Mat subImg = img(cv::Rect(cutImageX, cutImageY, img.cols - cutImageX, img.rows - cutImageY));
    mouth_cascade.detectMultiScale( subImg, mouths, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE|CV_HAAR_FIND_BIGGEST_OBJECT, cv::Size(30, 30) );

    //UO
    for( uint i = 0; i < mouths.size(); i++ )  //per ogni faccia
    {
        mouths[i].y += cutImageY;
        mouths[i].x += cutImageX;
    }

#ifdef WITH_GUI
    if(gui!=NULL)
    {
        gui->showFaceElements(mouths, face);
    }
#endif //WITH_GUI

    return;
}



------------- HAAR.H -----------------
void detectNoses(cv::Mat& img, cv::Rect& face);
std::vector<cv::Rect> getNoses();
std::vector<cv::Rect> noses;
void detectLeftEyes(cv::Mat& img, cv::Rect& face);
void detectRightEyes(cv::Mat& img, cv::Rect& face);
std::vector<cv::Rect> getLeftEyes();
std::vector<cv::Rect> getRightEyes();
std::vector<cv::Rect> leftEyes;
std::vector<cv::Rect> rightEyes;
void detectEyePairs(cv::Mat& img, cv::Rect& face);
std::vector<cv::Rect> getEyePairs();
std::vector<cv::Rect> getSingleEyes();
std::vector<cv::Rect> eyePairs;
std::vector<cv::Rect> singleEyes;
void detectSingleEyes(cv::Mat& img, cv::Rect& face);
void detectMouths(cv::Mat& img, cv::Rect& face);
std::vector<cv::Rect> getMouths();
std::vector<cv::Rect> mouths;
